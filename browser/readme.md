# 浏览器相关

一些参考资料：

[[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872)](https://segmentfault.com/a/1190000012925872)

[浏览器灵魂之问，请问你能接得住几个？](https://juejin.cn/post/6844904021308735502)

[深入理解现代浏览器](https://juejin.cn/post/6905952553490448397)

[前端都该懂的浏览器工作原理，你懂了吗？](https://juejin.cn/post/6844904158131126279)

[多角度理解浏览器工作（从输入url到页面呈现）](https://juejin.cn/post/6867075801133776909)





## 1、进程和线程

![](../imgs/img21.png)



### 1-1、简单区分一下进程与线程

- 进程是一个工厂，工厂有它的独立资源，所以进程也有系统分配的一块独立内存
- 工厂之间相互独立，因此进程之间也是相互独立
- 线程是工厂中的工人，多个工人协作完成任务，多个线程在进程中协作完成任务
- 工厂内有一个或多个工人，所以对应的一个进程由一个或多个线程组成
- 工人之间共享空间，所以同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）



**官方回答：**

- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）



### 1-2、浏览器中的进程

上面说过，浏览器是多进程的，下面就来看看主要是哪些进程：

 ![](../imgs/img8.png)

- 浏览器进程：负责页面展示、用户交互、子进程管理、提供存储等

  > 浏览器进程主要管理浏览器操作，例如打开页面，输入 url 等，它还有调度其他进程的功能

- 网络进程：主要负责网络资源加载（html、css、js、静态资源等）

- 渲染进程：每个 Tab 页卡都有单独的渲染进程，核心用于渲染页面

- `GPU`进程：3d 绘制，提高性能

- 插件进程：浏览器中安装的一些插件

> 不同进程之间也可以通信，不过代价较大



在浏览器内，每打开一个 tab，就相当于创建了一个独立的浏览器进程。当然，也不是一定的，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程）。

具体可以通过 Chrome 的 `更多工具 -> 任务管理器` 查看浏览器进程信息。



**多进程的优势：**

相比于单进程浏览器，多进程有如下优点：

- 避免单个页面崩溃影响整个浏览器
- 避免第三方插件崩溃影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

简单点理解：**如果浏览器是单进程，那么某个 Tab 页崩溃了，就影响了整个浏览器，体验非常差；同理如果是单进程，插件崩溃了也会影响整个浏览器；最主要的就是，多进程保证的浏览器的稳定性。**

当然，相应的内存等资源消耗也会更大，有点空间换时间的意思。



### 1-3、渲染进程

对于前端而言，最重要的是渲染进程。





## 2、从输入 URL 到浏览器显示页面发生了什么



### 2-1、浏览器进程的相互调用

1. 用户输入 url （关键字：会将关键字根据默认的搜索引擎生成地址）地址，开始导航

   > 这一步是在浏览器进程里面做的

2. 准备一个渲染进程，用于渲染页面

3. 通过网络进程加载资源，将加载到的资源交由渲染进程来处理

4. 在渲染的过程中，如果有 3d 动画，将调用 GPU 进程来处理

5. 渲染完毕，显示页面

   > 进程间通信都是使用 ipc 形式，即：postMessage、webWorker 等



### 2-2、URL 请求过程

**网络七层模型：**

- 物理层

- 数据链路层

  > 一般来讲，物理层与数据链路层归为网络接口层，比如说电缆、光纤之类的

- 网络层（ip）

- 传输层（tcp：安全可靠[三次握手]，分段传输，但是慢、udp：快[仅需发送一次确认]，但是会存在丢包）

- 会话层

- 表示层

- 应用层

  > 会话层、表示层、应用层归为应用层，主要就是 http



**一张经典的图：**

![](../imgs/img22.png)



**网络 OSI 七层模型与 TCP/IP 四层模型：**

 <img src="../imgs/img9.png" style="zoom: 80%;" />



**在浏览器中输入 URL：**

1. 输入的一般是域名，会先去查找缓存，检测缓存是否过期，如果没有过期，则直接返回缓存的内容

2. 查看域名是否被解析过（如果域名被请求国，那么就代表解析过），没有 DNS 解析域名成 ip 地址（DNS 实际上就是做了一个映射表，把域名和 ip 地址做了一个映射）

   > DNS 是基于UDP 的。为什么 DNS 不基于 TCP：因为在解析的过程中，涉及到服务器的查找，而服务会分成一级、二级域名等等，会迭代去查询，如果采用 TCP，那么没经过一次域名都要进行三次握手，那么将会非常慢

3. 如果是 https，还会经过 SSL 协商

4. 根据 ip 地址来寻找服务器；需要排队等待，因为在 http 1.1 中规定，一次最多只能同时发送 6 个请求

5. tcp 创建连接用于传输（三次握手）

6. 利用 tcp 传输数据（拆分成数据包，有序的发送，丢包有重发机制），服务器会按照顺序接收数据包

7. http 请求（请求行、请求头、请求体）

   > 在 http1.1 中，默认不会断开，有 keep-alive：为了下次传输数据时可以复用上次创建的链接，避免的建立链接消耗时间

8. 服务器收到数据后，解析数据，响应给浏览器（响应行、状态码、响应头、响应体）

9. 状态码 304 协商缓存



### 2-3、HTTP 发展历史流程

1. http 0.9：只负责传输 html，最早的时候没有请求头和请求体，不能传输 js 或者静态资源等
2. http1.0：提供了请求头，那么就可以根据请求头的不同来处理不同的资源，但是它有很多缺点，例如每次请求完都会断开链接，需要重新创建链接，带来较大的时间成本，需要手动 keep-alive
3. http1.1：默认开启了 keep-alive 链路复用，管线化（一个域名下最多可以建立6个链接）。但是服务器处理请求是按照顺序来的，虽然发送是并发发送6个，但是响应还是按照顺序一一处理（即队头阻塞）。而且 6 个链接，会建立6个tcp，那么会有带宽争抢的情况
4. http2.0：用同一个 tcp 发送数据，一个域名一个 tcp（多路复用）、头部压缩、双向链接（不止客户端可以先发起请求，也可以服务端先推送数据）
5. http3.0：解决了 tcp 的队头阻塞问题。最重要的是 http3.0 不再采用 tcp，而是使用 udp，并且加了 QUIC 协议



### 2-4、渲染流程

![](../imgs/img10.png)





## 3、请求 ---> 渲染流程

