## 浏览器渲染原理和性能优化



### 1、进程和线程

- 进程是操作系统资源分配的基本单位，进程中包含线程
- 线程由进程进行管理，为了提升浏览器稳定性和安全性，浏览器采用的是多进程模型

稳定性：浏览器多进程可以保证如果打开的某一个 Tab 卡掉了，不会影响到其他的 Tab，浏览器不会崩掉。



#### 1-1、浏览器中的5个进程

![](../imgs/img8.png)

- 浏览器进程：负责页面展示、用户交互、子进程管理、提供存储等

  > 浏览器进程主要管理浏览器操作，例如打开页面，输入 url 等，它还有调度其他进程的功能

- 网络进程：主要负责网络资源加载（html、css、js、静态资源等）

- 渲染进程：每个 Tab 页卡都有单独的渲染进程，核心用于渲染页面

- `GPU`进程：3d 绘制，提高性能

- 插件进程：浏览器中安装的一些插件



### 2、从输入 URL 到浏览器显示页面发生了什么



#### 2-1、浏览器进程的相互调用

1. 用户输入 url （关键字：会将关键字根据默认的搜索引擎生成地址）地址，开始导航

   > 这一步是在浏览器进程里面做的

2. 准备一个渲染进程，用于渲染页面

3. 通过网络进程加载资源，将加载到的资源交由渲染进程来处理

4. 在渲染的过程中，如果有 3d 动画，将调用 GPU 进程来处理

5. 渲染完毕，显示页面

   > 进程间通信都是使用 ipc 形式，即：postMessage、webWorker 等



#### 2-2、URL 请求过程

**网络七层模型：**

- 物理层

- 数据链路层

  > 一般来讲，物理层与数据链路层归为网络接口层，比如说电缆、光纤之类的

- 网络层（ip）

- 传输层（tcp：安全可靠[三次握手]，分段传输，但是慢、udp：快[仅需发送一次确认]，但是会存在丢包）

- 会话层

- 表示层

- 应用层

  > 会话层、表示层、应用层归为应用层，主要就是 http

![](../imgs/img9.png)

**在浏览器中输入 URL：**

1. 输入的一般是域名，会先去查找缓存，检测缓存是否过期，如果没有过期，则直接返回缓存的内容

2. 查看域名是否被解析过（如果域名被请求国，那么就代表解析过），没有 DNS 解析域名成 ip 地址（DNS 实际上就是做了一个映射表，把域名和 ip 地址做了一个映射）

   > DNS 是基于UDP 的。为什么 DNS 不基于 TCP：因为在解析的过程中，涉及到服务器的查找，而服务会分成一级、二级域名等等，会迭代去查询，如果采用 TCP，那么没经过一次域名都要进行三次握手，那么将会非常慢

3. 如果是 https，还会经过 SSL 协商

4. 根据 ip 地址来寻找服务器；需要排队等待，因为在 http 1.1 中规定，一次最多只能同时发送 6 个请求

5. tcp 创建连接用于传输（三次握手）

6. 利用 tcp 传输数据（拆分成数据包，有序的发送，丢包有重发机制），服务器会按照顺序接收数据包

7. http 请求（请求行、请求头、请求体）

   > 在 http1.1 中，默认不会断开，有 keep-alive：为了下次传输数据时可以复用上次创建的链接，避免的建立链接消耗时间

8. 服务器收到数据后，解析数据，响应给浏览器（响应行、状态码、响应头、响应体）

9. 状态码 304 协商缓存



#### 2-3、HTTP 发展历史流程

1. http 0.9：只负责传输 html，最早的时候没有请求头和请求体，不能传输 js 或者静态资源等
2. http1.0：提供了请求头，那么就可以根据请求头的不同来处理不同的资源，但是它有很多缺点，例如每次请求完都会断开链接，需要重新创建链接，带来较大的时间成本，需要手动 keep-alive
3. http1.1：默认开启了 keep-alive 链路复用，管线化（一个域名下最多可以建立6个链接）。但是服务器处理请求是按照顺序来的，虽然发送是并发发送6个，但是响应还是按照顺序一一处理（即队头阻塞）。而且 6 个链接，会建立6个tcp，那么会有带宽争抢的情况
4. http2.0：用同一个 tcp 发送数据，一个域名一个 tcp（多路复用）、头部压缩、双向链接（不止客户端可以先发起请求，也可以服务端先推送数据）
5. http3.0：解决了 tcp 的队头阻塞问题。最重要的是 http3.0 不再采用 tcp，而是使用 udp，并且加了 QUIC 协议


#### 2-4、渲染流程

![](../imgs/img10.png)



### 3、请求 ---> 渲染流程

